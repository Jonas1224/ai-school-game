<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Flappy Bird</title>
    <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@latest/dist/tf.min.js"></script>
    <style>
        body {
            margin: 0;
            height: 100vh;
            display: flex;
            flex-direction: row;
            align-items: center;
            justify-content: center;
            background: linear-gradient(180deg, #87ceeb, #e0f6ff);
            font-family: 'Press Start 2P', cursive;
            overflow: hidden;
            gap: 20px;
        }

        #game-container {
            position: relative;
            text-align: center;
        }

        #game {
            border: 2px solid #333;
            border-radius: 10px;
            box-shadow: 0 8px 16px rgba(0, 0, 0, 0.2);
            background: url('data:image/svg+xml;utf8,<svg xmlns="http://www.w3.org/2000/svg" width="400" height="600"><rect width="400" height="600" fill="%2387ceeb"/><g transform="translate(0,500)"><rect width="400" height="100" fill="%2394d82d"/></g></svg>');
        }

        #play-button {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            padding: 15px 30px;
            font-size: 24px;
            font-family: 'Press Start 2P', cursive;
            color: #fff;
            background: linear-gradient(45deg, #ff6b6b, #ff8e53);
            border: 3px solid #333;
            border-radius: 10px;
            cursor: pointer;
            transition: transform 0.2s, background 0.3s;
        }

        #play-button:hover {
            transform: translate(-50%, -50%) scale(1.1);
            background: linear-gradient(45deg, #ff8e53, #ff6b6b);
        }

        #play-button:focus {
            outline: none;
        }

        #score {
            position: absolute;
            top: 20px;
            left: 20px;
            color: #fff;
            font-size: 20px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }

        #game-over {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            color: #fff;
            font-size: 24px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
            display: none;
        }

        #data-count {
            position: absolute;
            top: 60px;
            left: 20px;
            color: #fff;
            font-size: 16px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }

        #controls {
            display: flex;
            flex-direction: column;
            gap: 15px;
            padding: 20px;
            background: rgba(255, 255, 255, 0.2);
            border-radius: 10px;
            box-shadow: 0 4px 8px rgba(0, 0, 0, 0.1);
        }

        #controls button {
            padding: 10px 20px;
            font-size: 14px;
            font-family: 'Press Start 2P', cursive;
            color: #fff;
            background: linear-gradient(45deg, #4caf50, #8bc34a);
            border: 2px solid #333;
            border-radius: 8px;
            cursor: pointer;
            transition: transform 0.2s, background 0.3s;
        }

        #controls button:hover {
            transform: scale(1.05);
            background: linear-gradient(45deg, #8bc34a, #4caf50);
        }

        #controls button:focus {
            outline: none;
        }

        #pause-record {
            background: linear-gradient(45deg, #ffc107, #ffeb3b);
        }

        #pause-record:hover {
            background: linear-gradient(45deg, #ffeb3b, #ffc107);
        }

        #clear-dataset {
            background: linear-gradient(45deg, #f44336, #e57373);
        }

        #clear-dataset:hover {
            background: linear-gradient(45deg, #e57373, #f44336);
        }

        #download-dataset {
            background: linear-gradient(45deg, #2196f3, #64b5f6);
        }

        #download-dataset:hover {
            background: linear-gradient(45deg, #64b5f6, #2196f3);
        }

        #train-model {
            background: linear-gradient(45deg, #673ab7, #9575cd);
        }

        #train-model:hover {
            background: linear-gradient(45deg, #9575cd, #673ab7);
        }

        #start-ai {
            background: linear-gradient(45deg, #00bcd4, #4dd0e1);
        }

        #start-ai:hover {
            background: linear-gradient(45deg, #4dd0e1, #00bcd4);
        }

        #stop-ai {
            background: linear-gradient(45deg, #e53935, #ef9a9a);
        }

        #stop-ai:hover {
            background: linear-gradient(45deg, #ef9a9a, #e53935);
        }

        #upload-dataset {
            background: linear-gradient(45deg, #9c27b0, #ce93d8);
        }

        #upload-dataset:hover {
            background: linear-gradient(45deg, #ce93d8, #9c27b0);
        }

        #training-status {
            font-size: 12px;
            color: #fff;
            text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.5);
            text-align: center;
        }
    </style>
</head>
<body>
    <div id="controls">
        <button id="start-record">Start Recording</button>
        <button id="pause-record">Pause Recording</button>
        <button id="clear-dataset">Clear Dataset</button>
        <button id="download-dataset">Download CSV</button>
        <input type="file" id="upload-dataset" accept=".csv" style="display: none;">
        <button id="upload-button">Upload CSV</button>
        <button id="train-model">Train Model</button>
        <button id="start-ai">Start AI Play</button>
        <button id="stop-ai">Stop AI Play</button>
        <div id="training-status"></div>
    </div>
    <div id="game-container">
        <canvas id="game" width="400" height="600"></canvas>
        <div id="score">Score: 0</div>
        <div id="data-count">Data Points: 0</div>
        <div id="game-over">Game Over</div>
        <button id="play-button">Play</button>
    </div>
    <script>
        class Bird {
            constructor() {
                this.pos = { x: 50, y: 300 };
                this.vel = { y: 0 };
                this.radius = 20;
                this.color = '#ffd700';
            }
            reset() {
                this.pos = { x: 50, y: 300 };
                this.vel = { y: 0 };
            }
        }

        class Pipe {
            constructor(canvasHeight, x) {
                this.x = x;
                this.width = 40;
                this.gapSize = 200;
                this.gapCenter = Math.random() * (canvasHeight - 300) + 150;
                this.color = '#228b22';
            }
            get top() {
                return this.gapCenter - this.gapSize / 2;
            }
            get bottom() {
                return this.gapCenter + this.gapSize / 2;
            }
        }

        class Game {
            constructor() {
                this.canvas = document.getElementById('game');
                this.ctx = this.canvas.getContext('2d');
                this.bird = new Bird();
                this.pipes = [];
                this.score = 0;
                this.state = 'menu';
                this.keys = {};
                this.gravity = 0.2;
                this.jumpStrength = -5;
                this.pipeSpeed = 2;
                this.pipeInterval = 250;
                this.nextPipeDist = 0;
                this.prevSpace = false;
                this.scoreEl = document.getElementById('score');
                this.dataCountEl = document.getElementById('data-count');
                this.gameOverEl = document.getElementById('game-over');
                this.playButton = document.getElementById('play-button');
                this.trainingStatusEl = document.getElementById('training-status');
                this.isRecording = false;
                this.isAI = false;
                this.dataset = [];
                this.pressedThisInterval = false;
                this.model = null;
                this.featureStats = null;
                this.aiPredictionCount = 0;

                this.startRecordBtn = document.getElementById('start-record');
                this.pauseRecordBtn = document.getElementById('pause-record');
                this.clearDatasetBtn = document.getElementById('clear-dataset');
                this.downloadDatasetBtn = document.getElementById('download-dataset');
                this.uploadDatasetInput = document.getElementById('upload-dataset');
                this.uploadButton = document.getElementById('upload-button');
                this.trainModelBtn = document.getElementById('train-model');
                this.startAIBtn = document.getElementById('start-ai');
                this.stopAIBtn = document.getElementById('stop-ai');

                this.startRecordBtn.onclick = () => {
                    this.isRecording = true;
                };
                this.pauseRecordBtn.onclick = () => {
                    this.isRecording = false;
                };
                this.clearDatasetBtn.onclick = () => {
                    this.dataset = [];
                    this.updateDataCount();
                };
                this.downloadDatasetBtn.onclick = () => this.downloadCSV();
                this.uploadButton.onclick = () => this.uploadDatasetInput.click();
                this.uploadDatasetInput.onchange = (e) => this.uploadCSV(e);
                this.trainModelBtn.onclick = () => this.trainModel();
                this.startAIBtn.onclick = () => {
                    if (!this.model) {
                        alert('Train the model first!');
                        return;
                    }
                    this.isAI = true;
                    if (this.state === 'menu' || this.state === 'dead') {
                        this.startGame();
                    }
                };
                this.stopAIBtn.onclick = () => {
                    this.isAI = false;
                };

                this.canvas.tabIndex = 0;
                document.addEventListener('keydown', (e) => {
                    this.keys[e.key] = true;
                    if (e.key === ' ' && (this.state === 'menu' || this.state === 'dead') && !this.isAI) {
                        this.startGame();
                    }
                });
                document.addEventListener('keyup', (e) => {
                    this.keys[e.key] = false;
                    if (e.key === ' ') this.prevSpace = false;
                });
                this.playButton.onclick = () => {
                    if (!this.isAI) this.startGame();
                };
                this.playButton.addEventListener('keydown', (e) => {
                    if (e.key === ' ' && !this.isAI) this.startGame();
                });

                setInterval(() => {
                    if (this.state === 'playing' && this.isRecording) {
                        const row = this.getCurrentData();
                        this.dataset.push(row);
                        this.pressedThisInterval = false;
                        this.updateDataCount();
                    }
                    if (this.state === 'playing' && this.isAI && this.model) {
                        this.aiPredictionCount++;
                        let pred, shouldJump;
                        if (this.aiPredictionCount <= 1) {
                            pred = 1;
                            shouldJump = true;
                            console.log(`AI Prediction ${this.aiPredictionCount}: Forced Jump (pred=1)`);
                        } else {
                            const features = this.getFeatures();
                            const xs = tf.tensor2d([features]);
                            pred = this.model.predict(xs).dataSync()[0];
                            shouldJump = pred > 0.3; // Lowered threshold to reduce FN
                            console.log(`AI Prediction ${this.aiPredictionCount}:`, pred, 'Features:', features, 'Jump:', shouldJump);
                        }
                        if (shouldJump) {
                            this.bird.vel.y = this.jumpStrength;
                            console.log('AI Jump Triggered');
                        }
                    }
                }, 100);

                this.updateDataCount();
                this.loop();
            }

            computeStats(features) {
                const n = features.length;
                const means = new Array(5).fill(0);
                const stds = new Array(5).fill(0);
                for (let i = 0; i < n; i++) {
                    for (let j = 0; j < 5; j++) {
                        means[j] += features[i][j] / n;
                    }
                }
                for (let i = 0; i < n; i++) {
                    for (let j = 0; j < 5; j++) {
                        stds[j] += Math.pow(features[i][j] - means[j], 2) / (n - 1);
                    }
                }
                return { means, stds: stds.map(s => Math.sqrt(s) || 1) };
            }

            async trainModel() {
                if (this.dataset.length < 100) {
                    alert('Need at least 100 data points to train effectively!');
                    return;
                }
                this.trainingStatusEl.textContent = 'Training in progress...';

                const features = this.dataset.map(d => [
                    d.y / this.canvas.height,
                    d.vel / 10,
                    d.dist / this.canvas.width,
                    d.mid1 / this.canvas.height,
                    d.mid2 / this.canvas.height
                ]);
                const labels = this.dataset.map(d => [d.pressed]);

                this.featureStats = this.computeStats(features);
                const normalizedFeatures = features.map(row =>
                    row.map((val, i) => (val - this.featureStats.means[i]) / this.featureStats.stds[i])
                );

                const num1 = labels.filter(l => l[0] === 1).length;
                const num0 = labels.length - num1;
                const classWeight = { 0: 1, 1: 1 }; // Higher weight for positive class to reduce FN

                const indices = Array.from({ length: labels.length }, (_, i) => i);
                indices.sort(() => Math.random() - 0.5);
                const trainSize = Math.floor(0.8 * indices.length);
                const trainIndices = indices.slice(0, trainSize);
                const testIndices = indices.slice(trainSize);
                const trainFeatures = trainIndices.map(i => normalizedFeatures[i]);
                const trainLabels = trainIndices.map(i => labels[i]);
                const testFeatures = testIndices.map(i => normalizedFeatures[i]);
                const testLabels = testIndices.map(i => labels[i]);

                const xsTrain = tf.tensor2d(trainFeatures);
                const ysTrain = tf.tensor2d(trainLabels);
                const xsTest = tf.tensor2d(testFeatures);
                const ysTest = tf.tensor2d(testLabels);

                this.model = tf.sequential();
                this.model.add(tf.layers.dense({ inputShape: [5], units: 1, activation: 'sigmoid' }));
                this.model.compile({
                    optimizer: tf.train.adam(0.01),
                    loss: 'binaryCrossentropy',
                    metrics: ['accuracy']
                });

                await this.model.fit(xsTrain, ysTrain, {
                    epochs: 100,
                    batchSize: 32,
                    classWeight,
                    validationData: [xsTest, ysTest],
                    verbose: 0
                });

                const weights = this.model.getWeights()[0].dataSync();
                const bias = this.model.getWeights()[1].dataSync()[0];
                const predsTrain = this.model.predict(xsTrain).dataSync();
                const truesTrain = ysTrain.dataSync();
                const predsTest = this.model.predict(xsTest).dataSync();
                const truesTest = ysTest.dataSync();
                let tpTest = 0, fpTest = 0, fnTest = 0;
                let ssTotTest = 0, ssResTest = 0;
                const meanYTest = truesTest.reduce((sum, y) => sum + y, 0) / truesTest.length;

                for (let i = 0; i < predsTest.length; i++) {
                    const pred = predsTest[i] > 0.3 ? 1 : 0; // Lowered threshold for metrics
                    if (pred === 1 && truesTest[i] === 1) tpTest++;
                    if (pred === 1 && truesTest[i] === 0) fpTest++;
                    if (pred === 0 && truesTest[i] === 1) fnTest++;
                    ssTotTest += Math.pow(truesTest[i] - meanYTest, 2);
                    ssResTest += Math.pow(truesTest[i] - predsTest[i], 2);
                }

                const precisionTest = tpTest / (tpTest + fpTest) || 0;
                const recallTest = tpTest / (tpTest + fnTest) || 0;
                const f1Test = 2 * precisionTest * recallTest / (precisionTest + recallTest) || 0;
                const r2Test = ssTotTest ? 1 - ssResTest / ssTotTest : 0;
                const adjustedR2Test = 1 - (1 - r2Test) * (testFeatures.length - 1) / (testFeatures.length - 5 - 1);

                const n = features.length;
                const se = normalizedFeatures.map(row => row.reduce((sum, x, i) => sum + x * weights[i], bias));
                const seMean = Math.sqrt(se.reduce((sum, x) => sum + x * x, 0) / n);
                const pValues = weights.map(w => {
                    const z = w / (seMean || 1);
                    return 2 * (1 - this.normalCDF(Math.abs(z)));
                });

                console.log('=== Logistic Regression Report ===');
                console.table({
                    'Feature': ['y (norm)', 'vel (norm)', 'dist (norm)', 'mid1 (norm)', 'mid2 (norm)', 'Intercept'],
                    'Coefficient': [...weights, bias],
                    'P-Value': [...pValues, '-']
                });
                console.table({
                    'Metric': ['Test R²', 'Test Adjusted R²', 'Test F1 Score', 'Test Recall', 'Test Precision', 'False Negatives'],
                    'Value': [r2Test, adjustedR2Test, f1Test, recallTest, precisionTest, fnTest]
                });
                console.log('Confusion Matrix (Test Set):');
                console.table({
                    '': ['Predicted 0', 'Predicted 1'],
                    'Actual 0': [testFeatures.length - fpTest - fnTest, fpTest],
                    'Actual 1': [fnTest, tpTest]
                });

                this.trainingStatusEl.textContent = `Training done! Test F1: ${f1Test.toFixed(3)}, FN: ${fnTest}`;
            }

            normalCDF(z) {
                return 1 / (1 + Math.exp(-1.702 * z));
            }

            getFeatures() {
                const next = this.getNextPipe(0);
                const nextNext = this.getNextPipe(1);
                const raw = [
                    this.bird.pos.y / this.canvas.height,
                    this.bird.vel.y / 10,
                    next ? (next.x - this.bird.pos.x) / this.canvas.width : 1,
                    next ? next.gapCenter / this.canvas.height : this.bird.pos.y / this.canvas.height,
                    nextNext ? nextNext.gapCenter / this.canvas.height : this.bird.pos.y / this.canvas.height
                ];
                const normalized = this.featureStats ? raw.map((val, i) => {
                    const std = this.featureStats.stds[i];
                    const mean = this.featureStats.means[i];
                    const result = (val - mean) / std;
                    return result;
                }) : raw;
                return normalized;
            }

            updateDataCount() {
                this.dataCountEl.textContent = `Data Points: ${this.dataset.length}`;
            }

            getNextPipe(offset = 0) {
                const upcoming = this.pipes.filter(pipe => pipe.x > this.bird.pos.x).sort((a, b) => a.x - b.x);
                return upcoming[offset] || null;
            }

            getCurrentData() {
                const next = this.getNextPipe(0);
                const nextNext = this.getNextPipe(1);
                return {
                    pressed: this.pressedThisInterval ? 1 : 0,
                    y: this.bird.pos.y,
                    vel: this.bird.vel.y,
                    dist: next ? next.x - this.bird.pos.x : 1000,
                    mid1: next ? next.gapCenter : this.bird.pos.y,
                    mid2: nextNext ? nextNext.gapCenter : this.bird.pos.y
                };
            }

            downloadCSV() {
                if (this.dataset.length === 0) return;
                const csv = 'pressed,y,vel,dist,mid1,mid2\n' +
                    this.dataset.map(row => `${row.pressed},${row.y},${row.vel},${row.dist},${row.mid1},${row.mid2}`).join('\n');
                const blob = new Blob([csv], { type: 'text/csv' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = 'flappy_data.csv';
                a.click();
                URL.revokeObjectURL(url);
            }

            uploadCSV(event) {
                const file = event.target.files[0];
                if (!file) return;
                const reader = new FileReader();
                reader.onload = (e) => {
                    const text = e.target.result;
                    const lines = text.split('\n').slice(1); // Skip header
                    let validRows = 0;
                    lines.forEach((line, index) => {
                        const [pressed, y, vel, dist, mid1, mid2] = line.split(',').map(val => parseFloat(val));
                        if (
                            line.trim() &&
                            !isNaN(pressed) && (pressed === 0 || pressed === 1) &&
                            !isNaN(y) && !isNaN(vel) && !isNaN(dist) &&
                            !isNaN(mid1) && !isNaN(mid2)
                        ) {
                            this.dataset.push({ pressed, y, vel, dist, mid1, mid2 });
                            validRows++;
                        } else {
                            console.warn(`Invalid CSV row at line ${index + 2}: ${line}`);
                        }
                    });
                    this.updateDataCount();
                    this.trainingStatusEl.textContent = `Uploaded ${validRows} valid data points`;
                    this.uploadDatasetInput.value = ''; // Reset input
                };
                reader.readAsText(file);
            }

            startGame() {
                this.bird.reset();
                this.pipes = [new Pipe(this.canvas.height, this.canvas.width)];
                this.nextPipeDist = this.pipeInterval;
                this.score = 0;
                this.state = 'playing';
                this.gameOverEl.style.display = 'none';
                this.playButton.style.display = 'none';
                this.canvas.focus();
                this.prevSpace = false;
                this.keys[' '] = false;
                this.aiPredictionCount = 0;
                this.updateScore();
            }

            updateScore() {
                this.scoreEl.textContent = `Score: ${this.score}`;
            }

            update() {
                if (this.state !== 'playing') return;

                this.bird.vel.y += this.gravity;
                this.bird.pos.y += this.bird.vel.y;

                if (!this.isAI) {
                    if (this.keys[' '] && !this.prevSpace) {
                        this.bird.vel.y = this.jumpStrength;
                        this.prevSpace = true;
                        this.pressedThisInterval = true;
                    }
                }

                if (this.bird.pos.y + this.bird.radius > this.canvas.height || this.bird.pos.y - this.bird.radius < 0) {
                    this.state = 'dead';
                    this.gameOverEl.style.display = 'block';
                    this.playButton.style.display = 'block';
                    if (this.isAI) {
                        this.startGame();
                    }
                    return;
                }

                this.nextPipeDist -= this.pipeSpeed;
                if (this.nextPipeDist <= 0) {
                    this.pipes.push(new Pipe(this.canvas.height, this.canvas.width));
                    this.nextPipeDist = this.pipeInterval;
                }

                this.pipes = this.pipes.filter(pipe => pipe.x + pipe.width > 0);
                for (const pipe of this.pipes) {
                    pipe.x -= this.pipeSpeed;
                    if (
                        this.bird.pos.x + this.bird.radius > pipe.x &&
                        this.bird.pos.x - this.bird.radius < pipe.x + pipe.width &&
                        (this.bird.pos.y - this.bird.radius < pipe.top || this.bird.pos.y + this.bird.radius > pipe.bottom)
                    ) {
                        this.state = 'dead';
                        this.gameOverEl.style.display = 'block';
                        this.playButton.style.display = 'block';
                        if (this.isAI) {
                            this.startGame();
                        }
                        return;
                    }
                    if (pipe.x + pipe.width < this.bird.pos.x && !pipe.passed) {
                        pipe.passed = true;
                        this.score++;
                        this.updateScore();
                    }
                }
            }

            draw() {
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                this.ctx.beginPath();
                this.ctx.arc(this.bird.pos.x, this.bird.pos.y, this.bird.radius, 0, Math.PI * 2);
                this.ctx.fillStyle = this.bird.color;
                this.ctx.fill();
                this.ctx.strokeStyle = '#333';
                this.ctx.lineWidth = 2;
                this.ctx.stroke();

                for (const pipe of this.pipes) {
                    this.ctx.fillStyle = pipe.color;
                    this.ctx.fillRect(pipe.x, 0, pipe.width, pipe.top);
                    this.ctx.fillRect(pipe.x, pipe.bottom, pipe.width, this.canvas.height - pipe.bottom);
                    this.ctx.strokeStyle = '#333';
                    this.ctx.strokeRect(pipe.x, 0, pipe.width, pipe.top);
                    this.ctx.strokeRect(pipe.x, pipe.bottom, pipe.width, this.canvas.height - pipe.bottom);
                }
            }

            loop() {
                this.update();
                this.draw();
                requestAnimationFrame(() => this.loop());
            }
        }

        new Game();
    </script>
</body>
</html>
